# Sistema di autenticazione in un'applicazione Nuxt con Spring Boot e JWT.

# Introduzione

Il sistema di autenticazione si basa su un'applicazione **Nuxt 3** (frontend) che comunica con un backend **Spring Boot** tramite **JSON Web Token (JWT)**. L'obiettivo è proteggere le pagine riservate dell'applicazione (ad esempio un pannello di amministrazione) permettendo l'accesso solo agli utenti autenticati, e in alcuni casi solo a quelli con privilegi amministrativi. Quando un utente effettua il login, il backend Spring Boot verifica le credenziali e fornisce un token JWT firmato che rappresenta l'identità dell'utente. Il frontend Nuxt salva questo token e lo include in ogni richiesta successiva, così il backend può autenticare e autorizzare le API. In caso di token non valido o scaduto, l'utente viene reindirizzato alla pagina di login. Grazie a questo meccanismo, il sistema mantiene la sessione utente senza bisogno di sessioni server-side, sfruttando esclusivamente il token JWT per l'autenticazione stateless.

In sintesi, il flusso è il seguente: l'utente si registra o effettua il login ottenendo un token JWT; il token viene conservato sul client (ad es. in `localStorage`) e allegato a tutte le chiamate API protette; il frontend utilizza **Pinia** (store state management) per conservare dati utente e token, e **middleware di Nuxt** per proteggere le rotte e gestire i reindirizzamenti; un **plugin Axios** configura automaticamente l'invio del token JWT nelle intestazioni HTTP. Il risultato è un sistema di autenticazione completo che include gestione delle credenziali, mantenimento dello stato di login, controllo dei ruoli (ad esempio ruolo admin) e internazionalizzazione dell'interfaccia (grazie a un composable di i18n), garantendo un accesso sicuro e un'esperienza utente multilingua.

# Descrizione di ciascun file

Di seguito vengono descritti in dettaglio i file principali che compongono il sistema, suddivisi per tipologia (componenti Vue, composables, middleware, configurazione, plugin e store Pinia). Per ciascun file si illustrano la funzione principale, le caratteristiche del codice, le interazioni con gli altri componenti del sistema e le dipendenze o configurazioni necessarie.

## Componenti Vue

### Auth/LoginForm.vue

**Funzione principale:** Il componente `LoginForm.vue` fornisce il form di autenticazione dove l'utente inserisce username e password per effettuare il login. È responsabile di raccogliere le credenziali e interagire con il sistema di autenticazione sul frontend (tramite composables e store) per avviare il processo di login.

**Descrizione del codice:** Nel template, il componente espone un form con campi per **username** e **password**, una casella *"Remember me"* (ricordami) e un pulsante di submit. Utilizza le funzioni di traduzione `t()` fornite dal composable di internazionalizzazione per le etichette e i placeholder, così da supportare sia italiano che inglese nell'interfaccia. Se è presente un messaggio di errore (ad esempio credenziali errate), viene mostrato un alert rosso in cima al form. Ogni campo di input è collegato a proprietà reattive (`v-model`) per aggiornare lo stato locale del componente. Nel blocco `<script setup>`, il componente importa il composable `useAuth` (per le operazioni di autenticazione) e `useI18n` (per la traduzione) ([report_components_Auth_LoginForm.vue.md](./report_components_Auth_LoginForm.vue.md)). Vengono definite variabili reattive locali per `username`, `password`, `rememberMe` e `error`. La funzione chiave è `handleLogin`, invocata al submit del form (con `@submit.prevent="handleLogin"` nel template). Essa esegue alcune validazioni semplici (controlla che username e password non siano vuoti) e in caso manchi qualcosa mostra un messaggio di errore localizzato *"per favore riempi tutti i campi"* ([report_components_Auth_LoginForm.vue.md](./report_components_Auth_LoginForm.vue.md)). Se i campi sono compilati, chiama la funzione `login` fornita dal composable di autenticazione, passandole username, password e il valore di rememberMe ([report_components_Auth_LoginForm.vue.md](./report_components_Auth_LoginForm.vue.md)). La chiamata è effettuata in modalità asincrona (`await`) e il risultato (`success`) indica se il login ha avuto successo. In caso di fallimento, viene mostrato un messaggio di errore generico (o specifico se fornito dallo store) settando `error.value` con il messaggio appropriato (ad esempio *"login fallito"*) ([report_components_Auth_LoginForm.vue.md](./report_components_Auth_LoginForm.vue.md)). Durante la chiamata di login, il pulsante di submit viene disabilitato automaticamente usando la proprietà `loading` dallo store (esposta via composable) per evitare clic multipli, e può mostrare uno spinner di caricamento.

**Interazioni con altri file:** `LoginForm.vue` interagisce principalmente con i **composables** di autenticazione e i18n. In particolare, utilizza `useAuth` per ottenere la funzione `login` e le proprietà reattive `authError` (messaggi di errore) e `loading` (stato di caricamento) ([report_components_Auth_LoginForm.vue.md](file://file-RE734kmfb3rfo6zjZTMo32#:~:text=import%20,from%20%27~%2Fcomposables%2FuseI18n)). `useAuth` a sua volta incapsula le operazioni sullo store Pinia dell'autenticazione (store `auth.ts`). Quindi, quando `LoginForm.vue` chiama `login`, in realtà sta delegando allo store Pinia di autenticazione tramite il composable. Inoltre, `LoginForm.vue` usa `useI18n` per ottenere la funzione di traduzione `t()` ([report_components_Auth_LoginForm.vue.md](file://file-RE734kmfb3rfo6zjZTMo32#:~:text=import%20,from%20%27~%2Fcomposables%2FuseI18n)), così da mostrare testi nella lingua corrente (es. label dei campi, messaggi di errore). Dopo un login con successo, grazie alla logica interna di `useAuth`, l'utente viene reindirizzato alla home page dell'applicazione (rotte protette) senza che il componente debba gestirlo direttamente. In caso di errore, il messaggio proviene dallo store (`authError`) o da una stringa di traduzione, integrando così componenti, store e i18n.

**Dipendenze e configurazioni:** Questo componente assume che esistano traduzioni per le chiavi utilizzate (ad es. 'username', 'password', 'please_fill_all_fields', 'login_failed', ecc.) nei file di localizzazione caricati dal composable i18n. Dipende inoltre dal composable `useAuth` che a sua volta richiede uno store Pinia configurato (`auth.ts`). Il componente stesso è semplice e non necessita di configurazioni aggiuntive, ma richiede che il modulo Pinia sia attivo (configurato in `nuxt.config.ts`) e che il composable `useAuth` sia implementato correttamente. Inoltre fa affidamento sulla presenza di **Bootstrap CSS** (importato globalmente) per le classi utilizzate nel template (es. `form-control`, `btn btn-primary`, etc.), come indicato nella configurazione di Nuxt.

## Composables

I **composables** in Nuxt 3 (e Vue 3) sono funzioni riutilizzabili che incapsulano logica reattiva e possono essere importate nei componenti. In questo sistema di autenticazione, i composables fungono da interfaccia semplificata verso gli store Pinia e altri servizi (router, i18n), fornendo funzioni già pronte da usare nei componenti Vue.

### useAuth.ts

**Funzione principale:** `useAuth` è un composable che centralizza le operazioni di autenticazione (login, logout, registrazione, verifica dello stato) e fornisce ai componenti un accesso facile allo **store Pinia di autenticazione** e al router. In pratica, semplifica l'uso dello store `auth.ts` all'interno dei componenti Vue.

**Descrizione del codice:** La funzione `useAuth()` importa lo store Pinia dell’autenticazione tramite `useAuthStore()` e il router di Vue (`useRouter()`) ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=%2F%2F%20composables%2FuseAuth.ts%20import%20,router)). Restituisce un oggetto con funzioni e proprietà utili per gestire l'autenticazione. Le funzioni includono: `login(username, password, rememberMe)`, `logout()`, `register(userData)` e `checkAuth()`. Quando si chiama `login`, il composable invoca l'azione corrispondente nello store Pinia e attende il risultato; in caso di successo, esegue un redirect programmatico alla home page (`router.push('/')`) ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20login%20%3D%20async%20,return%20success%3B)) per portare l'utente autenticato all’interno dell’area protetta. La funzione `logout` invece chiama semplicemente `authStore.logout()` per resettare lo stato di autenticazione e poi effettua un redirect alla pagina di login (`/login`) ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20logout%20%3D%20%28%29%20%3D,push%28%27%2Fauth%2Flogin%27%29%3B)). `register` utilizza lo store per registrare un nuovo utente e, in caso positivo, reindirizza l'utente alla pagina di login, presumibilmente per farlo autenticare dopo la registrazione ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20register%20%3D%20async%20,return%20success)). Infine `checkAuth` richiama `authStore.initAuth()`, che serve ad inizializzare lo stato dell'utente (ad esempio leggere un token eventualmente presente in local storage e validarlo) – utile da eseguire all'avvio dell'app. Oltre a queste funzioni, `useAuth` espone proprietà derivate dallo store Pinia sotto forma di **computed properties** di sola lettura: ad esempio `isAuthenticated`, `isAdmin`, `user`, `loading`, `error` ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=return%20,authStore.loading)). Queste permettono ai componenti di reagire ai cambiamenti dello stato di autenticazione (ad esempio mostrare/nascondere elementi in base all'utente loggato o al ruolo admin, disabilitare pulsanti durante l'elaborazione, mostrare errori di login, ecc.).

**Interazioni con altri file:** `useAuth` comunica strettamente con lo **store `auth.ts`** da cui ottiene sia lo stato (utente attuale, token, ecc.) sia le azioni (login/logout/etc). Agisce come uno strato intermedio: i componenti (come `LoginForm.vue`) chiamano le funzioni di `useAuth`, che a loro volta delegano la logica allo store Pinia e al **router**. Ad esempio, `useAuth.login` chiama `authStore.login` e poi usa `router.push` per navigare ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20login%20%3D%20async%20,return%20success%3B)). Questa separazione rende i componenti più puliti, poiché non devono sapere i dettagli di implementazione dello store o del router. `useAuth` dipende inoltre dal fatto che il **Pinia store** sia definito e registrato (cosa configurata in `nuxt.config.ts` con `@pinia/nuxt`) e che il **router** di Nuxt sia disponibile (Nuxt 3 fornisce `useRouter()` di default). Non interagisce direttamente con il plugin Axios o altri composables, ma indirettamente le azioni dello store che `useAuth` invoca (come `authStore.login`) utilizzeranno Axios per le chiamate API.

**Dipendenze o configurazioni:** `useAuth` richiede che esista uno store Pinia chiamato 'auth' (definito in `stores/auth.ts`) e che Pinia sia stato aggiunto ai moduli di Nuxt. Inoltre, assume che esista una route denominata `'/'` per la home protetta e `'/login'` per il form di login, dove effettuare i redirect post-login o post-logout. In fase di configurazione, è bene registrare questo composable (anche se in Nuxt 3 i composables in `~/composables` vengono resi disponibili automaticamente). Non necessita di altre configurazioni se non quelle già menzionate (router, store e rotte esistenti).

### useI18n.ts

**Funzione principale:** `useI18n` fornisce funzionalità di **internazionalizzazione** (i18n) fatte in casa, permettendo all'app di gestire testi in più lingue (ad esempio inglese e italiano) senza utilizzare plugin esterni. Questo composable consente di caricare file di traduzione, ottenere la lingua corrente, cambiare lingua e tradurre chiavi testuali.

**Descrizione del codice:** All'inizio definisce alcune variabili di stato: `currentLanguage` (lingua attualmente selezionata, inizializzata dal localStorage dell'utente o default `'en'`) e un oggetto reattivo `translations` che conterrà i dizionari di traduzione ([report_composables_useI18n.ts.md](file://file-5QQXDYu715BnrugAU9qNyK#:~:text=const%20currentLanguage%20%3D%20ref%28localStorage.getItem%28%27user_language%27%29%20,Translations)) ([report_composables_useI18n.ts.md](file://file-5QQXDYu715BnrugAU9qNyK#:~:text=translations.value%20%3D%20,)). La funzione `loadTranslations` carica in modo asincrono i file JSON delle traduzioni per le lingue supportate (nell'esempio, inglese e italiano) attraverso fetch su percorsi come `/locales/en.json` e `/locales/it.json` ([report_composables_useI18n.ts.md](file://file-5QQXDYu715BnrugAU9qNyK#:~:text=async%20function%20loadTranslations%28%29%20,json)). Una volta ottenuti i dati, popola l'oggetto `translations` con le chiavi delle due lingue. La funzione principale `useI18n()` restituisce diverse proprietà e metodi utili: `setLanguage(lang)` per cambiare la lingua corrente salvando anche la preferenza in localStorage e impostando l'attributo `lang` del tag HTML `<html>` (utile per accessibilità e SEO) ([report_composables_useI18n.ts.md](file://file-5QQXDYu715BnrugAU9qNyK#:~:text=%2F%2F%20Switch%20language%20and%20save,setItem%28%27user_language%27%2C%20lang)); `t(key)` per tradurre una chiave testuale restituita nel dizionario della lingua corrente (se la chiave non esiste, restituisce la chiave stessa come fallback) ([report_composables_useI18n.ts.md](file://file-5QQXDYu715BnrugAU9qNyK#:~:text=const%20t%20%3D%20,key%3B)); `availableLanguages`, un elenco delle lingue disponibili (codice e nome) da poter usare ad esempio in un menu di selezione ([report_composables_useI18n.ts.md](file://file-5QQXDYu715BnrugAU9qNyK#:~:text=%2F%2F%20Available%20languages%20const%20availableLanguages,)); infine, la proprietà `currentLanguage` come **computed** reattivo per leggere la lingua attiva dall'esterno. Questo composable implementa anche un *pattern Singleton* semplice: utilizza variabili di modulo (fuori dalla funzione `useI18n`) in modo che la lingua corrente e le traduzioni siano condivise tra tutte le istanze e mantenute durante l'uso dell'app (così non si ricaricano ad ogni chiamata).

**Interazioni con altri file:** Il composable i18n è utilizzato nei componenti che devono mostrare testi tradotti, come il `LoginForm.vue` (che usa `t('username')` etc. per le etichette) e presumibilmente altri componenti dell'interfaccia. Inoltre, la **configurazione di Nuxt** registra un middleware globale `'i18n'` (vedi `nuxt.config.ts`) che potrebbe chiamare `loadTranslations()` all'avvio di ogni rotta o impostare la lingua corretta per l'utente. Anche se il file del middleware i18n non è stato fornito, è probabile che esista per pre-caricare le traduzioni e/o applicare la lingua scelta su navigazione. `useI18n` non interagisce con lo store Pinia o con Axios, poiché la sua responsabilità è limitata ai testi statici dell'interfaccia. Dipende dall'esistenza dei file JSON delle traduzioni in una cartella pubblica (`/locales/en.json` e `/locales/it.json`) e dall'uso di `localStorage` del browser per salvare la scelta linguistica dell'utente.

**Dipendenze o configurazioni:** Non necessita di pinia né di configurazioni speciali di Nuxt se non l'eventuale middleware globale menzionato. Bisogna assicurarsi che i file di traduzione siano accessibili e che i componenti chiamino `useI18n().loadTranslations()` almeno una volta (ad esempio all'avvio dell'app) per caricare le stringhe. Inoltre, occorre inserire in `nuxt.config.ts` il middleware i18n (come fatto in questo progetto) affinché la localizzazione sia inizializzata per ogni pagina. In assenza di moduli esterni di i18n, questo composable è una soluzione manuale per la gestione multilingua.

### useUsers.ts

**Funzione principale:** `useUsers` è un composable che astrae le operazioni relative agli utenti (diversi dall'utente attualmente autenticato) ed è pensato soprattutto per l'amministrazione di un elenco utenti. Fornisce funzioni per *fetch* (recupero) di utenti, creazione, aggiornamento e cancellazione di un utente tramite lo store Pinia `users.ts`. In sostanza, è l'interfaccia usata dai componenti dell'area amministrativa per gestire gli utenti registrati nel sistema.

**Descrizione del codice:** Importa lo store Pinia degli utenti tramite `useUsersStore()` ([report_composables_useUsers.ts.md](file://file-BFWfBj82yuWMaHMHtCyRgL#:~:text=import%20,stores%2Fusers)). All'interno di `useUsers()` definisce funzioni asincrone che chiamano le corrispondenti azioni dello store: `fetchUsers(page, size)`, `fetchUser(login)` per ottenere un singolo utente, `createUser(userData)`, `updateUser(login, userData)` e `deleteUser(login)` ([report_composables_useUsers.ts.md](file://file-BFWfBj82yuWMaHMHtCyRgL#:~:text=const%20fetchUsers%20%3D%20async%20,fetchUsers%28page%2C%20size%29%3B)) ([report_composables_useUsers.ts.md](file://file-BFWfBj82yuWMaHMHtCyRgL#:~:text=const%20updateUser%20%3D%20async%20,updateUser%28login%2C%20userData%29%3B)). Ognuna di queste usa `await` per invocare l'azione dello store e restituisce direttamente il risultato (ad esempio, la lista di utenti caricata, il singolo utente, o un booleano di successo per le operazioni di creazione/modifica). Infine, il composable restituisce un oggetto contenente le funzioni sopra definite e alcune proprietà derivate dallo store: `users` (lista di utenti), `currentUser` (utente correntemente selezionato/dettagliato), `loading` (stato di caricamento) ed `error` (eventuale errore) ([report_composables_useUsers.ts.md](file://file-BFWfBj82yuWMaHMHtCyRgL#:~:text=return%20%7B%20users%3A%20computed%28%28%29%20%3D,error%29%2C%20fetchUsers%2C%20fetchUser%2C%20createUser%2C%20updateUser)). Queste proprietà sono fornite come **computed properties** che leggono lo stato interno dello store Pinia degli utenti, consentendo ai componenti di reagire automaticamente ai cambiamenti (per esempio aggiornare la UI quando la lista utenti viene caricata).

**Interazioni con altri file:** `useUsers` utilizza fortemente lo **store `users.ts`** incapsulando le sue azioni. I componenti di gestione utenti (ad esempio un componente AdminUserList.vue o AdminUserEdit.vue, non forniti qui ma facilmente immaginabili) chiameranno `useUsers()` per ottenere le funzioni e i dati necessari. Lo store `users.ts` a sua volta interagisce con l'API backend tramite Axios, e richiede il token JWT per autorizzare le operazioni (solo gli admin possono gestire utenti). In questo flusso, `useUsers` non parla direttamente con `useAuth`, ma indirettamente le sue azioni controllano lo stato di autenticazione amministrativa tramite lo store utenti che verifica `authStore.isAdmin` prima di procedere (vedi descrizione store utenti sotto). Dunque, la sequenza tipica potrebbe essere: un componente admin importa `useUsers`, chiama ad esempio `const { users, fetchUsers } = useUsers()`, la funzione `fetchUsers` nello store invia la richiesta all'API includendo il token. Una volta ricevuti i dati, lo store aggiorna `users` e la proprietà reattiva `users` restituita dal composable si aggiorna nel componente. Il composable dipende anche dallo store di autenticazione in maniera indiretta: le azioni che invoca nello store utenti internamente consultano `useAuthStore` per token e permessi.

**Dipendenze o configurazioni:** `useUsers` richiede che il **Pinia store** degli utenti (`users.ts`) sia definito e registrato. Inoltre, assume che esistano le relative API sul backend (ad esempio endpoint REST `/api/admin/users` per lista utenti, come appare nelle chiamate Axios) e che vengano passati token JWT validi (cosa garantita dallo store e dal plugin Axios). Non necessita di configurazioni particolari se non l'accesso allo store Pinia (fornito tramite `@pinia/nuxt` già configurato) e la presenza del composable di autenticazione qualora fosse necessario gestire casi particolari (in ogni caso lo store utenti verifica internamente l'autenticazione). 

## Middleware

I **middleware** di Nuxt 3 sono funzioni che si eseguono prima di accedere a una rotta (pagina) e possono decidere di continuare la navigazione o reindirizzare altrove. In questo progetto vengono usati per proteggere le pagine che richiedono autenticazione o privilegi specifici (admin), verificando lo stato di login dell'utente tramite lo store di autenticazione prima di rendere accessibile la pagina.

### auth.ts (middleware di autenticazione generale)

**Funzione principale:** Il middleware `auth.ts` protegge le rotte che richiedono un utente autenticato. Il suo scopo è impedire l’accesso a pagine interne se l'utente non ha effettuato il login, reindirizzandolo verso la pagina di autenticazione. Gestisce anche il caso opposto: se l'utente è già autenticato e cerca di accedere alle pagine di login/registrazione, lo reindirizza alla home (evitando che un utente loggato riveda la schermata di login).

**Descrizione del codice:** Il middleware ottiene lo store Pinia dell'autenticazione tramite `useAuthStore()`. Per prima cosa, evita di eseguire qualsiasi logica lato server (`if (process.server) return;`) perché l'inizializzazione dello stato avviene solo sul client (dato che l'app è SPA) ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=if%20%28%21authStore.isAuthenticated%29%20)). Quindi verifica se l'utente risulta autenticato nello store (`authStore.isAuthenticated`). Se **non** lo è, chiama `authStore.initAuth()` ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=if%20%28%21authStore.isAuthenticated%29%20)). Questa inizializzazione tenta di recuperare un token JWT dal `localStorage` e di decodificarlo per stabilire se l'utente ha una sessione valida (vedi store auth). Dopo `initAuth`, il middleware controlla di nuovo: se l'utente ancora non è autenticato e sta cercando di accedere a una rotta che **non** inizia per `/auth` (cioè non sta già andando verso login o registrazione), allora lo reindirizza a `/login` ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=%2F%2F%20If%20still%20not%20authenticated,return%20navigateTo%28%27%2Fauth%2Flogin%27%29%3B)). In pratica forza il redirect al form di login per qualsiasi pagina protetta se l'utente non ha una sessione valida. La seconda condizione gestisce l'altro scenario: se l'utente **è autenticato** e l'URL di destinazione inizia con `/auth` (es. prova ad aprire manualmente la pagina di login o registrazione pur essendo loggato), allora il middleware esegue un `navigateTo('/')` per mandarlo alla home page ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=%2F%2F%20If%20authenticated%20and%20trying,return%20navigateTo%28%27%2F%27%29%3B)), evitando accessi ridondanti alle pagine di autenticazione quando non necessario.

**Interazioni con altri file:** Questo middleware interagisce soprattutto con lo **store di autenticazione** (`auth.ts`). Fa uso dei getter `isAuthenticated` e dell'azione `initAuth` dello store ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=if%20%28%21authStore.isAuthenticated%29%20)). Inoltre utilizza la funzione `navigateTo` di Nuxt per i reindirizzamenti, che non richiede import esplicito (è fornita nel contesto dei middleware). Viene tipicamente associato alle pagine che devono essere protette. Può essere registrato come middleware globale oppure dichiarato a livello di singola pagina. Nel file di configurazione `nuxt.config.ts` vediamo che c'è un middleware globale `i18n`, ma non `auth` ([report_nuxt.config.ts.md](file://file-DnjTpmGTMcQ23EvQxKxfLv#:~:text=build%3A%20,)); ciò suggerisce che `auth.ts` venga applicato sulle rotte sensibili manualmente (ad esempio tramite la proprietà `middleware` nelle pagine della cartella `pages` o usando layout protetti). Ad esempio, la pagina home e altre sezioni interne potrebbero specificare `middleware: 'auth'` nel loro script, in modo che questo controllo venga eseguito ogni volta. Inoltre, questo middleware lavora in sinergia col **plugin Axios**: se il token JWT è scaduto, il backend restituirà un 401 e l'interceptor Axios provocherà un redirect al login (vedi più avanti), quindi il middleware `auth` assicura comunque che post-logout o al refresh non si rimanga in una pagina non autorizzata.

**Dipendenze o configurazioni:** `auth.ts` richiede che lo store Pinia di autenticazione sia disponibile e che l'app usi Pinia (in `nuxt.config.ts` lo vediamo abilitato). Inoltre presuppone l'esistenza delle rotte `/login` (pagina di login) e `/` (home protetta) verso cui fare redirect. Per funzionare correttamente su tutte le pagine protette, è necessario inserirlo in ogni route riservata (o impostarlo come middleware globale di default, se tutte le pagine tranne login devono essere protette). In questo caso, lo sviluppatore ha scelto di non farlo globale (forse per permettere pagine pubbliche come la homepage), quindi l'applicazione dovrebbe applicarlo dove serve. Non richiede altre configurazioni oltre a quelle del contesto Nuxt (la funzione `defineNuxtRouteMiddleware` viene usata per definirlo, come da convenzioni Nuxt 3).

### admin.ts (middleware per privilegi amministrativi)

**Funzione principale:** Il middleware `admin.ts` è specializzato nel proteggere le rotte che solo un amministratore dovrebbe poter accedere. In pratica, estende il controllo di autenticazione verificando anche che l'utente abbia il ruolo di **admin**, altrimenti lo blocca. Serve per sezioni come gestione utenti, pannello di amministrazione ecc.

**Descrizione del codice:** Similmente all'altro middleware, importa lo store di autenticazione e, se eseguito in ambiente server, esce immediatamente. Poi verifica: se l'utente non è autenticato (`!authStore.isAuthenticated`), lo reindirizza al login ([report_middleware_admin.ts.md](file://file-VfuZRgrT2EhsjRQtH62SoD#:~:text=if%20%28%21authStore.isAuthenticated%29%20,)). Questo assicura che solo utenti loggati possano procedere. Successivamente, se l'utente è autenticato ma non ha il flag `isAdmin` a true (che nello store verifica la presenza di `'ROLE_ADMIN'` nelle authorities) ([report_middleware_admin.ts.md](file://file-VfuZRgrT2EhsjRQtH62SoD#:~:text=if%20%28%21authStore.isAdmin%29%20)), allora l'accesso viene negato reindirizzando l'utente alla home page `/` (o ad altra pagina sicura). In sostanza, un utente comune che tentasse di accedere a rotte amministrative viene rimandato indietro alla pagina principale dell'app. Se invece `authStore.isAdmin` è true, il middleware non fa nulla e permette di continuare la navigazione verso la pagina richiesta (che verrà quindi caricata normalmente).

**Interazioni con altri file:** Il middleware admin dipende dallo **store `auth.ts`** per conoscere lo stato di autenticazione e il ruolo utente (tramite i getter `isAuthenticated` e `isAdmin`) ([report_middleware_admin.ts.md](file://file-VfuZRgrT2EhsjRQtH62SoD#:~:text=if%20%28%21authStore.isAuthenticated%29%20,)). Probabilmente è utilizzato insieme al middleware `auth.ts` oppure include implicitamente quel controllo. In pratica, su una rotta admin, conviene eseguire entrambi: prima `auth` per assicurarsi che la sessione sia valida (o includere la logica di initAuth come fatto in `auth.ts` stesso), poi `admin` per la specifica del ruolo. In molti casi, basta indicare in Nuxt il middleware 'admin' (che già richiama il login se non autenticato), come è implementato qui. Questo middleware non interagisce direttamente con il plugin Axios o i composables, ma il suo esito (reindirizzare alla home) implica che la pagina admin non verrà caricata se l'utente non ha privilegi, proteggendo così anche il caricamento di eventuali componenti che chiamerebbero `useUsers`. Insieme, questi middleware garantiscono che lo **store utenti** venga usato solo da chi ha i diritti: infatti lo store utenti stesso controlla `authStore.isAdmin` su ogni azione, come ulteriore sicurezza applicativa.

**Dipendenze o configurazioni:** `admin.ts` richiede che vi sia la proprietà `authorities` nell'oggetto utente dello store e che contenga `'ROLE_ADMIN'` per gli amministratori (cosa gestita dal backend Spring Boot e recuperata tramite l'endpoint `/account`). Lo store `auth.ts` calcola `isAdmin` appunto su quella base. Inoltre, come per `auth.ts`, sono necessarie le route di destinazione (`/login` e `/`) e l'integrazione di Pinia. Bisogna applicare questo middleware alle rotte sensibili, ad esempio definendo `middleware: 'admin'` nei file Vue delle pagine amministrative (tipicamente quelle sotto un path `/admin` o simili). Non vi sono altre configurazioni oltre al registro come middleware Nuxt.

## Configurazione di Nuxt (nuxt.config.ts)

**Funzione principale:** Il file `nuxt.config.ts` definisce la configurazione globale dell'applicazione Nuxt. In questo contesto, include settaggi importanti per l'autenticazione come la disattivazione del rendering lato server, l'aggiunta dei moduli necessari (Pinia), la configurazione del runtime (URL base delle API backend), fogli di stile globali e middleware di default.

**Descrizione dettagliata:** Nella configurazione fornita, `ssr` è impostato a `false` ([report_nuxt.config.ts.md](file://file-DnjTpmGTMcQ23EvQxKxfLv#:~:text=devtools%3A%20,scale%3D1%27)), il che significa che l'app verrà eseguita interamente sul lato client (SPA pura). Questa scelta è comune quando si ha un'applicazione separata dal backend e si utilizzano token JWT, poiché la logica di autenticazione (e l'uso di localStorage) avviene solo nel browser. Vengono aggiunti stili globali come Bootstrap CSS e un file CSS personalizzato (`@/assets/css/main.css`) ([report_nuxt.config.ts.md](file://file-DnjTpmGTMcQ23EvQxKxfLv#:~:text=css%3A%20)) per la grafica dell'app. Sotto `modules` troviamo `'@pinia/nuxt'` ([report_nuxt.config.ts.md](file://file-DnjTpmGTMcQ23EvQxKxfLv#:~:text=modules%3A%20,)), necessario per abilitare Pinia come store state management in Nuxt. Un elemento chiave è `runtimeConfig.public`: al suo interno è definita `apiBase` con valore `'http://localhost:8080/api'` ([report_nuxt.config.ts.md](file://file-DnjTpmGTMcQ23EvQxKxfLv#:~:text=runtimeConfig%3A%20,)). Questa variabile rappresenta l'URL di base per le chiamate API al backend Spring Boot (in questo caso in locale su porta 8080, percorso `/api`). Viene usata all'interno del codice (ad esempio negli store con `useRuntimeConfig()`) per costruire gli endpoint delle richieste Axios. Essendo in `public`, è accessibile anche sul client. In `app.head` vediamo la configurazione standard dell'header HTML (title, meta tag, favicon) e l'abilitazione degli strumenti di sviluppo (`devtools: true`). Inoltre, appare una sezione `routes: { middleware: ['i18n'] }` ([report_nuxt.config.ts.md](file://file-DnjTpmGTMcQ23EvQxKxfLv#:~:text=build%3A%20,)) che indica come **middleware globale** l'esecuzione di `i18n` su tutte le rotte. Ciò significa che prima di ogni navigazione di pagina verrà eseguito anche il middleware di internazionalizzazione (presumibilmente per caricare le traduzioni o settare la lingua giusta in base magari a preferenze utente). Non è specificato qui il middleware `auth` come globale, segno che l'app potrebbe avere sia parti pubbliche che private, e si preferisce applicare `auth` solo dove serve, mentre `i18n` va sempre eseguito per gestire la lingua.

**Interazioni con altri file:** La configurazione influenza molti aspetti: grazie a `@pinia/nuxt`, i composables come `useAuthStore` possono funzionare (Pinia viene inizializzato e integrato nel contesto Nuxt). La voce `runtimeConfig.public.apiBase` viene utilizzata nei file degli store e nel plugin Axios. Ad esempio, nello store `auth.ts` si legge la config con `const config = useRuntimeConfig();` e poi si usa `config.public.apiBase` per costruire l'URL delle chiamate (`/authenticate`, `/account`, ecc.) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=try%20,username%2C%20password%2C%20rememberMe)) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20config%20%3D%20useRuntimeConfig,this.token%7D%60%20%7D)). Lo stesso avviene nello store `users.ts` per chiamare endpoint come `/admin/users` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)). Avere l'URL centralizzato in config consente di modificare facilmente l'indirizzo del backend (ad esempio per puntare a un server diverso in produzione) senza cambiare il codice del componente/store. L'aver disabilitato SSR (`ssr: false`) incide sui middleware che controllano `process.server` (evitando che cerchino di eseguire logica su rendering iniziale) e consente l'uso diretto di oggetti come `localStorage` nei composables e plugin, cosa che altrimenti in SSR puro richiederebbe controlli aggiuntivi. Il middleware globale `i18n` menzionato viene automaticamente applicato a tutte le rotte, il che richiama implicazioni su `useI18n` (ad esempio potrebbe invocare `loadTranslations()` all'inizio di ogni navigazione o settare la lingua attuale). Infine, l'inclusione di CSS globali (Bootstrap) facilita la creazione del componente di login e altri senza dover importare CSS in ogni singolo file.

**Dipendenze o configurazioni necessarie:** La configurazione mostra dipendenze esterne come `bootstrap` (inserito nei CSS) e Pinia. Assicura anche che l'app front-end sappia dove contattare il backend (`apiBase`). È importante che sul backend Spring Boot le API corrispondano a questo path (`/api/authenticate`, `/api/account`, ecc.) e che il server consenta richieste CORS dal dominio della Nuxt app se servita su un host differente. La config presuppone inoltre l'esistenza del middleware `i18n` (che deve essere implementato affinché quell'entry non sia inutile). In contesti di produzione, `runtimeConfig` può essere alimentato da variabili d'ambiente per non hardcodare l'URL. Nel complesso, `nuxt.config.ts` prepara il terreno tecnico su cui poi operano componenti, store, plugin e middleware descritti.

## Plugin (Axios)

### plugins/axios.ts

**Funzione principale:** Il plugin Axios (`plugins/axios.ts`) configura globalmente Axios nell'app Nuxt, impostando l'URL base per le API e soprattutto gestendo gli **intercettori (interceptors)** sia delle richieste che delle risposte per includere automaticamente il token JWT nelle chiamate e reagire a eventuali errori di autenticazione. In pratica, questo plugin fa in modo che tutte le richieste HTTP partite dall'app verso il backend Spring Boot abbiano l'header di Authorization corretto e che, se il token non è valido (ad esempio scaduto), l'utente venga disconnesso/rimandato al login.

**Descrizione del codice:** Nel `defineNuxtPlugin` viene ottenuto il `runtimeConfig` pubblico e configurato `axios.defaults.baseURL` con il valore di `config.public.apiBase` ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=axios)), cosicché ogni chiamata `axios` utilizzi automaticamente l'URL di base `http://localhost:8080/api` (o quello configurato) come prefisso. Successivamente, viene aggiunto un **interceptor per le richieste** (`axios.interceptors.request.use`). Questo intercettore viene eseguito prima che ogni richiesta HTTP parta: legge da `localStorage` l'item `auth_token` (dove salviamo il JWT) ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=%28config%29%20%3D,token%7D%60%3B%20%7D%20return%20config)) e, se presente, aggiunge un header HTTP Authorization con valore `Bearer <token>` alla richiesta ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=%28config%29%20%3D,token%7D%60%3B%20%7D%20return%20config)). In questo modo, tutte le chiamate Axios al backend portano automaticamente il token di autenticazione senza doverlo specificare manualmente ogni volta nel codice. C'è poi l'interceptor delle **risposte** (`axios.interceptors.response.use`). Questo gestisce globalmente le risposte HTTP: se una risposta di errore ha status 401 (Non autorizzato) o 403 (Proibito) ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=%7D%2C%20%28error%29%20%3D,return%20Promise.reject%28error%29%3B)), significa che il token JWT è mancante, non valido o scaduto. In tal caso, l'interceptor esegue: rimozione dell’`auth_token` dal localStorage (per pulire eventuali credenziali non più valide) e redirect forzato del browser alla pagina di login (`window.location.href = '/login'`) ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=%7D%2C%20%28error%29%20%3D,return%20Promise.reject%28error%29%3B)). Questo comportamento garantisce che se la sessione scade (o l'utente prova ad accedere a una risorsa senza permessi), venga immediatamente riportato al form di login, e che lo stato locale venga ripulito. Infine, il plugin registra Axios nell'app tramite `provide: { axios }` ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=return%20,)), anche se in questo caso l'uso è opzionale perché gli store importano già axios direttamente. Ciò permette comunque di usare `NuxtApp.$axios` o composables di Nuxt per accedere ad Axios se volessimo.

**Interazioni con altri file:** Il plugin Axios lavora dietro le quinte in coordinamento con gli **store Pinia** e il **middleware**: quando lo store `auth.ts` salva il token in localStorage ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)), l'interceptor di richiesta inizierà a includerlo nelle chiamate seguenti. Quando gli store `auth.ts` o `users.ts` effettuano chiamate con `axios.get/post/put/delete`, queste passeranno per l'interceptor che aggiunge l'header Authorization, anche se nello store è stato specificato manualmente (notiamo che negli store spesso viene aggiunto l'header esplicitamente `Authorization: Bearer ...` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20response%20%3D%20await%20axios.get%28%60%24,this.token%7D%60%20%7D)) ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)), risultando ridondante ma innocuo). In caso il backend risponda con 401/403, l'interceptor di risposta rimuove il token e reindirizza al login; ciò influisce sullo store `auth.ts` perché se il token viene rimosso da localStorage, al prossimo initAuth lo store vedrà che non c'è più un token e dunque l'utente risulterà disconnesso. Questo completa il ciclo di **logout automatico** su token scaduto. I middleware di rotta (`auth` e `admin`) insieme a questo meccanismo assicurano che l'utente non resti mai con credenziali invalide: appena c'è un problema, viene fatto tornare alla login. Il plugin dipende dal valore di `apiBase` definito in `nuxt.config.ts`, quindi interagisce indirettamente con quella configurazione. Inoltre, richiamando `window.location.href` invece di `navigateTo`, si bypassa la logica di Nuxt e si forza un reload completo sulla pagina di login, garantendo che lo store venga resettato.

**Dipendenze o configurazioni necessarie:** È fondamentale che `localStorage` sia disponibile (in ambiente browser) e che il token JWT sia memorizzato con la chiave esatta `'auth_token'` come previsto. Questo viene fatto nello store di autenticazione dopo il login ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)). Bisogna inoltre registrare il plugin in Nuxt (cosa che avviene automaticamente ponendo il file in `plugins/axios.ts`). Axios dev'essere installato come dipendenza nel progetto. Dal lato backend, il server Spring Boot deve accettare il token nel header `Authorization: Bearer ...` e rispondere con 401/403 appropriatamente quando il token non è valido, in modo che l'interceptor possa attivarsi. Non sono necessarie configurazioni aggiuntive nel plugin stesso, a parte assicurarsi che eventuali chiamate a risorse pubbliche gestiscano il caso in cui non ci sia token (l'interceptor semplicemente non aggiunge l'header se `auth_token` non è impostato). Nel complesso, questo plugin è cruciale per la **sicurezza** e la comodità: centralizza la gestione del token sulle richieste senza ripetere codice in ogni chiamata API.

## Store di Pinia

Gli **store Pinia** contengono lo stato reattivo condiviso e le azioni (metodi) per modificarlo, analogamente a Vuex ma in versione semplificata e tipizzata. In questo progetto, esistono due store principali: uno per l'autenticazione dell'utente corrente (`auth.ts`) e uno per la gestione degli utenti del sistema (per funzioni amministrative, `users.ts`). Entrambi sono definiti con `defineStore` e sfruttano Axios per comunicare col backend.

### stores/auth.ts (Store di Autenticazione)

**Funzione principale:** Lo store `auth.ts` si occupa di gestire tutto ciò che riguarda l'utente attualmente autenticato e il token JWT associato. Comprende lo stato di login (se l'utente è autenticato o meno), i dati del profilo utente, il token JWT, eventuali errori di autenticazione e le azioni per login, logout, registrazione e persistenza della sessione. È il cuore lato client del sistema di autenticazione JWT.

**Stato e Getter:** Nello store, tipicamente definito con `defineStore('auth')`, lo **stato** iniziale (`state`) contiene: `token` (stringa JWT o null se non loggato), `user` (oggetto utente con informazioni come username, email, ruoli, ecc., oppure null), `loading` (booleano usato per indicare operazioni in corso, es. login in corso) ed `error` (messaggio di errore ultimo occorso, o null) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=state%3A%20%28%29%3A%20AuthState%20%3D,loading%3A%20false%2C%20error%3A%20null)). I **getters** includono `isAuthenticated` (ritorna true se esistono sia un token che un utente, ovvero sessione attiva) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=getters%3A%20,return%20this.token)), `isAdmin` (true se l'utente corrente ha il ruolo amministratore, cioè se nella lista `authorities` dell'utente è presente `'ROLE_ADMIN'` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=getters%3A%20,null))), `getToken` e `getUser` per ottenere rispettivamente il token e l'oggetto utente dallo stato. Questi getters permettono ad altre parti dell'app (composables, componenti, altri store) di conoscere rapidamente lo stato di autenticazione.

**Azioni principali:** Lo store definisce diverse **azioni** (funzioni che mutano lo stato ed eseguono logica asincrona se necessario):
- `initAuth()`: Serve a inizializzare lo stato di autenticazione al caricamento dell'app. Legge il token JWT da `localStorage` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=initAuth%28%29%20,now%28%29%20%2F%201000)). Se trova un token, prova a decodificarlo con la libreria `jwt-decode` (importata in cima allo store) per verificare che non sia scaduto confrontando il timestamp di scadenza (`exp`) con l'ora corrente ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=if%20%28token%29%20,now%28%29%20%2F%201000)). Se il token è valido (non scaduto), lo imposta nello stato (`this.token = token`) e chiama `this.fetchUserData()` per caricare i dettagli dell'utente dal backend ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=if%20%28decodedToken.exp%20,else)). Se il token è mancante, scaduto o invalido, esegue il logout (rimuovendo eventuali tracce e ripristinando lo stato non autenticato) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=%7D%20else%20,logout%28%29%3B)). Questa funzione non ritorna nulla ma prepara lo store per l'uso. Viene tipicamente invocata all'avvio dell'app (ad esempio dal middleware `auth.ts`).
- `login(username, password, rememberMe)`: Gestisce il processo di autenticazione. Imposta `loading = true` ed azzera errori all'inizio. Poi invia una richiesta POST all'endpoint `/authenticate` del backend, utilizzando Axios ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=try%20,username%2C%20password%2C%20rememberMe)). L'URL completo è costruito con `config.public.apiBase + '/authenticate'` e il payload JSON contiene `username`, `password` e `rememberMe` (quest'ultimo booleano che indica se la sessione deve essere "ricordata" a lungo termine lato server). Se la richiesta va a buon fine (`try`), il backend dovrebbe restituire un oggetto con il token JWT (ad esempio `{ id_token: '...JWT...' }`). Il codice estrae `id_token` dalla risposta e lo salva nello stato `this.token` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)). Subito dopo, salva anche il token nel `localStorage` del browser con chiave `'auth_token'` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)) per conservarlo tra refresh di pagina. Poi richiama `await this.fetchUserData()` per ottenere i dati del profilo utente associato al token appena ricevuto ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)). Infine, imposta `return true` indicando successo. In caso di errore (credenziali errate o altro), cattura l'eccezione, estrae eventualmente un messaggio di dettaglio dall'errore di Axios (spesso il backend fornisce un messaggio `error.response.data.detail`), lo salva in `this.error` e ritorna false ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=return%20true%3B%20,loading%20%3D%20false%3B)). Nel blocco `finally`, mette `loading = false` per indicare fine operazione. Da notare che, grazie al plugin Axios, il token ottenuto sarà anche automaticamente usato per successive chiamate API.
- `fetchUserData()`: Dopo un login riuscito (o un `initAuth` con token valido), questa azione chiama l'endpoint `/account` del backend per ottenere le informazioni aggiornate dell'utente loggato. Usa una richiesta GET autorizzata: costruisce l'URL `config.public.apiBase + '/account'` e include l'header Authorization con `Bearer <token>` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20config%20%3D%20useRuntimeConfig,this.token%7D%60%20%7D)) (anche qui l'interceptor Axios lo aggiungerebbe comunque, ma lo store lo passa esplicitamente). Se la chiamata ha successo, la risposta conterrà probabilmente un oggetto utente (id, nome, cognome, email, ruoli, ecc.). Lo store assegna `this.user = response.data` aggiornando così lo stato utente ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20config%20%3D%20useRuntimeConfig,this.token%7D%60%20%7D)). In caso di errore (ad esempio token non valido), logga l'errore in console e chiama `this.logout()` per assicurarsi di rimuovere eventuali dati incoerenti ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=this.user%20%3D%20response.data%3B%20,finally)). Nel `finally` rimette `loading = false`. Questa funzione è fondamentale per popolare `authStore.user` e consentire l'uso di dati utente (incluso il ruolo admin per i controlli).
- `register(userData)`: Consente di registrare un nuovo utente chiamando l'endpoint `/register` del backend. Imposta loading, pulisce errori, poi effettua un `axios.post` verso `config.public.apiBase + '/register'` inviando i dati del nuovo utente (tipicamente nome, email, password, ecc.) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=try%20,config.public.apiBase%7D%2Fregister%60%2C%20userData%29%3B%20return%20true)). Se la registrazione va a buon fine, ritorna `true`. Se c'è un errore (ad esempio username/email già in uso), salva il messaggio di errore in `this.error` e ritorna false ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=await%20axios.post%28%60%24,%27Registration%20failed%27%3B%20return%20false)). Al termine rimette `loading = false`. Dopo una registrazione riuscita, di solito il flusso prevede che l'utente effettui login manualmente con le credenziali create (il composable `useAuth.register` infatti reindirizza alla pagina di login).
- `logout()`: Semplice ma cruciale, rimuove il token dallo stato (imposta `this.token = null`) e i dati utente (`this.user = null`), e pulisce il token anche da `localStorage` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=logout%28%29%20,removeItem%28%27auth_token%27%29%3B)). In questo modo l'utente viene considerato non autenticato. Non serve a chiamare un endpoint di logout sul server poiché con JWT il logout è gestito client-side (basta dimenticare il token; sarà il server a rifiutare il token se scaduto o revocato).
- `updateCurrentUser(userData)`: (Opzionale) Consente di aggiornare i dati del profilo dell'utente corrente inviando una richiesta (es. per cambiare nome, email, etc.). Prima controlla di avere un utente e token valido; poi invia un `axios.post` a `/account` con il payload delle modifiche e l'header Authorization ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=try%20,this.token%7D%60%20%7D%20%7D)). Se va a buon fine, aggiorna `this.user` con la risposta (dati utente aggiornati) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=this,this.loading%20%3D%20false)). Se errore, imposta `this.error`. Questo metodo non è strettamente legato all'autenticazione, ma offre la funzionalità di profilo utente.

**Interazioni con altri file:** Lo store di autenticazione è utilizzato ovunque serva conoscere lo stato di login o effettuare operazioni di login/logout. Viene richiamato dal **composable `useAuth`** (che a sua volta è usato nei componenti come LoginForm). Ad esempio, `useAuthStore.login` è invocato in `useAuth.login` ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20login%20%3D%20async%20,return%20success%3B)) quando l'utente preme "Accedi". Il middleware `auth.ts` utilizza `authStore.isAuthenticated` e `authStore.initAuth` per verificare e inizializzare la sessione ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=if%20%28%21authStore.isAuthenticated%29%20)). Il middleware `admin.ts` legge `authStore.isAdmin` ([report_middleware_admin.ts.md](file://file-VfuZRgrT2EhsjRQtH62SoD#:~:text=if%20%28%21authStore.isAdmin%29%20)) per decidere l'accesso. Anche lo store `users.ts` interagisce con questo store: all'inizio di ogni sua azione, controlla `useAuthStore().isAuthenticated` e `isAdmin` prima di procedere ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=async%20fetchUsers,%21authStore.isAdmin%29%20return)), e utilizza `authStore.getToken` per ottenere il token da mettere negli header delle richieste utente ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)). Il plugin Axios è influenzato dallo store: quando `authStore.login` salva il token in localStorage ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)), l'interceptor comincerà a utilizzarlo. Se il token scade e il backend manda errore, l'interceptor rimuove il token da localStorage; di conseguenza, se l'app prova a usare ancora `authStore.isAuthenticated`, potrebbe trovare `token` ancora presente in stato fino a un refresh, ma `initAuth` al prossimo percorso lo correggerà (per questo lo store decodifica e controlla scadenza ad ogni init). In pratica, store di auth è il **singolo punto di riferimento** per sapere se l'utente è loggato e chi è. Qualsiasi componente può ottenere queste info via composable (`useAuth`). Ad esempio, un componente di navbar potrebbe fare `const { isAuthenticated, user, logout } = useAuth()` e utilizzare tali proprietà per mostrare il nome utente loggato e un pulsante di logout (che chiamerebbe `logout()` per terminare la sessione).

**Dipendenze o configurazioni necessarie:** Lo store `auth.ts` dipende dalla libreria **jwt-decode** per decodificare i token JWT (importata in testa al file) e dall'istanza Axios configurata (importa axios globalmente) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=%2F%2F%20stores%2Fauth.ts%20import%20,decode%27%3B%20import%20axios%20from%20%27axios)). Inoltre, utilizza `useRuntimeConfig()` di Nuxt per leggere l'URL base delle API ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=try%20,username%2C%20password%2C%20rememberMe)), quindi richiede che `runtimeConfig.public.apiBase` sia configurato in `nuxt.config.ts` (come infatti è). Funziona in combinazione col localStorage del browser per conservare il token: è importante che la chiave `'auth_token'` sia coerente tra store e plugin Axios. Bisogna anche che il backend Spring Boot implementi gli endpoint attesi:
- `POST /authenticate` che restituisce `id_token` JWT se le credenziali sono corrette,
- `GET /account` che restituisce i dettagli dell'utente corrente (richiede token),
- `POST /register` che crea un nuovo utente (pubblico),
- (ed eventualmente `POST /account` per update profilo).
Inoltre, il token JWT deve avere un campo `exp` (scadenza) che lo store controlla. Nel nostro codice, `JwtPayload` interfaccia definisce `sub`, `auth` (probabilmente il ruolo/authorities in formato stringa concatenata) e `exp`, `iat`. Lo store presume che se `decodedToken.exp > now` il token sia ancora valido ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=if%20%28token%29%20,now%28%29%20%2F%201000)). Se la struttura fosse diversa, bisognerebbe adattare questo controllo. In conclusione, configurare correttamente l'indirizzo API e includere jwt-decode sono passi necessari perché lo store funzioni. Pinia deve essere attivo e il store registrato (fatto automaticamente in Nuxt se il file è nella cartella `stores/`).

### stores/users.ts (Store di Gestione Utenti)

**Funzione principale:** Lo store `users.ts` gestisce l'elenco degli utenti dell'applicazione e operazioni CRUD sugli utenti. È pensato per l'uso da parte di un amministratore: infatti verifica sempre che l'utente corrente sia autenticato e abbia ruolo admin prima di eseguire qualsiasi azione. Mantiene nello stato la lista di utenti caricati, i dettagli dell'utente attualmente selezionato (ad es. per visualizzare o modificare), informazioni di paginazione e eventuali errori. 

**Stato e Getter:** Lo **stato** (`UsersState`) include: `users` (array di utenti caricati), `currentUser` (oggetto utente selezionato, ad esempio per mostrare i dettagli o modificarlo), `loading` (bool per operazioni in corso), `error` (stringa per l'ultimo errore), `totalItems` (numero totale di utenti, se il backend lo fornisce per paginazione), `page` e `size` correnti (indice di pagina e dimensione usata nell'ultima query) ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=interface%20UsersState%20,page%3A%20number%3B%20size%3A%20number%3B)). I **getters** offrono scorciatoie come `getUsers` per ottenere l'array utenti, `getCurrentUser` e `isLoading` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=getters%3A%20%7B%20getUsers%3A%20%28state%29%20%3D,state.loading)), utili a componenti che vogliono accedere allo stato senza modificarlo.

**Azioni principali:** Tutte le azioni di questo store prevedono chiamate all'API backend (sotto il path `/admin/users` presumibilmente protetto da ruolo admin) e utilizzano Axios. Notare che all'inizio di ogni azione c'è un controllo su autenticazione e ruolo admin usando `useAuthStore()`:
- `fetchUsers(page = 0, size = 20)`: recupera la lista utenti paginata. Se l'utente non è autenticato o non è admin, esce immediatamente (return) senza fare nulla ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=async%20fetchUsers,%21authStore.isAdmin%29%20return)). Altrimenti, imposta loading true, resetta error, e fa la richiesta GET a `${apiBase}/admin/users` passando come query params la pagina e size desiderate, e includendo l'header Authorization con il token ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)). In caso di successo, popola `this.users` con `response.data` (l'API probabilmente restituisce direttamente l'array di utenti, oppure un oggetto con elementi e meta; qui si assume array) ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=this,size%20%3D%20size)), e memorizza `page` e `size` nello stato. Ritorna infine l'array di utenti. In caso di errore, salva un messaggio di errore generico o dettagliato in `this.error` e ritorna un array vuoto ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=%7D%20catch%20%28error%3A%20any%29%20,loading%20%3D%20false%3B)). Infine, comunque, mette `loading = false` nel finally.
- `fetchUser(login)`: ottiene i dettagli di un singolo utente identificato da login (username). Anche qui, prima verifica se l'utente corrente è admin ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=%2F%2F%20Fetch%20a%20single%20user,%21authStore.isAdmin%29%20return%20null)). Poi effettua GET `${apiBase}/admin/users/${login}` con header Authorization ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=try%20,authStore.getToken%7D%60%20%7D)). Se va a buon fine, assegna il risultato a `this.currentUser` e lo ritorna ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=this,loading%20%3D%20false%3B)). Errori vengono salvati in `this.error` e ritorna null in quel caso.
- `createUser(userData)`: crea un nuovo utente con i dati forniti. Richiede permesso admin ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=async%20createUser%28userData%3A%20Partial,%21authStore.isAdmin%29%20return%20false)). Mette loading true, error null, e invia una POST a `${apiBase}/admin/users` con il payload `userData` e header Authorization ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=try%20,authStore.getToken%7D%60%20%7D)). Se l'operazione riesce (il server potrebbe restituire l'utente creato o solo successo), lo store dopo la await chiama `this.fetchUsers(this.page, this.size)` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=)) per aggiornare la lista utenti corrente, così da includere l'eventuale nuovo utente inserito. Ritorna true se tutto ok. Se c'è un errore (es. utente con stessa login già esistente), salva il messaggio in `this.error` e ritorna false ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=await%20this,loading%20%3D%20false%3B)). Loading false nel finally.
- `updateUser(login, userData)`: aggiorna un utente esistente. Stessa struttura: verifica admin ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=%2F%2F%20Update%20an%20existing%20user,%21authStore.isAdmin%29%20return%20false)), poi PUT a `${apiBase}/admin/users/${login}` con nuovi dati ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=await%20axios.put%28%60%24,authStore.getToken%7D%60%20%7D)). Se ok, richiama `fetchUsers` per ricaricare la lista aggiornata ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=await%20this,this.loading%20%3D%20false)) e ritorna true. Errori gestiti con `this.error`.
- `deleteUser(login)`: elimina un utente. Solo se admin ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=%2F%2F%20Delete%20a%20user%20async,%21authStore.isAdmin%29%20return%20false)), poi DELETE `${apiBase}/admin/users/${login}` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=try%20,authStore.getToken%7D%60%20%7D)). Se ok, richiama `fetchUsers` per aggiornare la lista ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=)) e ritorna true; altrimenti errore in `this.error`.

In tutte le operazioni di modifica (create/update/delete), dopo l'azione sul server si richiama `fetchUsers` con la pagina e size correnti per sincronizzare lo stato locale con il backend (ad esempio, se aggiungo un utente, la lista locale viene ricaricata comprensiva del nuovo). Ciò semplifica la coerenza dei dati mostrati all'admin.

**Interazioni con altri file:** Lo store utenti interagisce principalmente con lo **store di autenticazione**: ogni sua azione utilizza `useAuthStore()` per accedere a `isAuthenticated`, `isAdmin` e al token tramite `authStore.getToken` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=async%20fetchUsers,%21authStore.isAdmin%29%20return)) ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)). In questo modo, prima di fare qualunque chiamata protetta, conferma che l'utente abbia diritto. Questa è una doppia garanzia oltre al middleware: se per qualsiasi ragione il middleware venisse bypassato, lo store comunque non esegue operazioni se l'utente non è admin. Lo store viene utilizzato dai **composables `useUsers`** descritti sopra: ad esempio, un componente potrebbe chiamare `useUsers().fetchUsers()` che internamente chiama questa azione store. I dati ottenuti (`users`, `currentUser`) possono poi essere letti tramite `useUsers().users` (che corrisponde a `usersStore.getUsers`). Il plugin Axios e il token JWT entrano in gioco qui: l'header Authorization viene aggiunto manualmente nelle chiamate ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)), ma anche se non lo fosse, l'interceptor del plugin l'avrebbe aggiunto comunque; questo store però dipende strettamente dalla presenza di un token valido in `authStore.getToken`. Inoltre, il flusso di logout o scadenza token influenza questo store: se l'utente viene deautenticato, `authStore.isAuthenticated` diventa false e quindi ulteriori chiamate (o anche la continuazione di quella corrente se in corso) non proseguiranno. Probabilmente, in caso di 401 dal server nelle chiamate di questo store, l'interceptor axios redirigerà al login, quindi queste azioni non avranno successo e `this.error` verrà settato (es. "Failed to fetch users"). Un componente admin potrebbe reagire a quell'errore mostrando un messaggio o venendo reindirizzato dal middleware. In generale, lo store utenti funge da ponte tra l'interfaccia di amministrazione e le API protette di gestione utenti sul backend.

**Dipendenze o configurazioni necessarie:** Lo store `users.ts` richiede che l'applicazione carichi anche lo store `auth.ts` (il quale viene importato internamente con `useAuthStore()`). Necessita di Axios configurato con il giusto `apiBase` e l'interceptor di autenticazione attivo. Inoltre, dipende dal backend Spring Boot che deve esporre gli endpoint:
- `GET /admin/users` (paginato, protetto da ruolo admin),
- `GET /admin/users/{login}` (dettaglio utente, admin),
- `POST /admin/users` (creazione utente, admin),
- `PUT /admin/users/{login}` (aggiornamento utente, admin),
- `DELETE /admin/users/{login}` (cancellazione utente, admin).
Questi tipicamente fanno parte di un API di amministrazione utenti (in molti framework vengono forniti di default, ad esempio un'app generata può avere queste rotte predefinite). Lo store presuppone che tali endpoint restituiscano i dati in forma utilizzabile immediatamente (lista utenti, utente singolo). Dal lato front-end, bisogna assicurarsi che Pinia sia installato e che questo store sia definito (Nuxt carica automaticamente i file in `stores/`). Non c'è configurazione aggiuntiva nel file stesso se non l'utilizzo coerente di `runtimeConfig` per ottenere l'URL base come negli altri store. Infine, la costante di paginazione default (page 0, size 20) può essere modificata a necessità, ma in assenza di parametri userà quei valori.

# Flusso di autenticazione

In questa sezione descriviamo come funziona il processo di autenticazione nell'applicazione, includendo il login, il logout, la gestione del token JWT e la protezione delle rotte tramite i middleware. 

**1. Processo di Login:** L'utente naviga alla pagina di login (`/login`), dove è montato il componente `LoginForm.vue`. Qui inserisce le proprie credenziali (username e password) e opzionalmente seleziona "Ricordami". Quando preme il pulsante di accesso, il componente esegue la funzione `handleLogin` ([report_components_Auth_LoginForm.vue.md](file://file-RE734kmfb3rfo6zjZTMo32#:~:text=if%20%28%21username.value%20%7C%7C%20%21password.value%29%20,value%20%3D%20t%28%27please_fill_all_fields%27%29%3B%20return%3B)) che, dopo aver validato i campi, richiama `useAuth().login(username, password, rememberMe)`. Questa funzione del composable a sua volta chiama l'azione `authStore.login` nello store Pinia ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20login%20%3D%20async%20,return%20success%3B)). Lo store effettua la richiesta API di autenticazione al backend Spring Boot: `POST /api/authenticate` inviando JSON con username, password e rememberMe ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=try%20,username%2C%20password%2C%20rememberMe)). Il server verifica le credenziali; se valide, risponde con un token JWT (nel campo `id_token`). Lo store estrae questo token ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)) e lo salva sia nello stato reattivo (`authStore.token`) sia nel `localStorage` del browser con chiave `'auth_token'` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)). A questo punto, il client ha memorizzato il token per successive richieste. Lo store poi chiama `fetchUserData()` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20,token%20%3D%20id_token)), che esegue `GET /api/account` usando il token appena ottenuto ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20config%20%3D%20useRuntimeConfig,this.token%7D%60%20%7D)). Il server risponde con i dettagli dell'utente (inclusi ruoli/autorizzazioni). Lo store salva questi dati in `authStore.user` ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=const%20config%20%3D%20useRuntimeConfig,this.token%7D%60%20%7D)) e imposta `isAuthenticated = true` (derivato dalla presenza di token+user). L'azione di login ritorna `true` al composable, il quale esegue `router.push('/')` ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20login%20%3D%20async%20,return%20success%3B)): l'utente viene reindirizzato dalla pagina di login alla homepage (o dashboard principale) ora che è autenticato. Durante tutto il processo, vari stati vengono aggiornati: `authStore.loading` è true durante la chiamata e false dopo, e se ci sono errori (es. credenziali errate), `authStore.error` viene impostato e propagato al componente per visualizzarlo. In caso di errore di login, nessun redirect viene fatto e l'utente rimane sulla pagina di login con un messaggio di errore.

**2. Gestione del token JWT dopo il login:** Una volta ottenuto, il token JWT è utilizzato per autenticare tutte le richieste API successive. Grazie al plugin Axios, ogni richiesta inviata includerà automaticamente l'header `Authorization: Bearer <token>` ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=%28config%29%20%3D,token%7D%60%3B%20%7D%20return%20config)). Questo significa che se, ad esempio, l'app chiama `axios.get('/admin/users')` dallo store utenti, l'intercettore aggiungerà l'header col token senza doverlo specificare manualmente (anche se nel nostro store utenti viene comunque aggiunto esplicitamente per precauzione ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D))). Il token è memorizzato in localStorage, quindi persiste anche se l'utente ricarica la pagina o chiude e riapre il browser (per un certo tempo). All'avvio dell'applicazione (o al refresh della pagina), entra in gioco l'azione `authStore.initAuth()`: essa viene tipicamente chiamata da un middleware globale o comunque eseguita prima di renderizzare le pagine protette. `initAuth` controlla se c'è un token salvato nel localStorage ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=initAuth%28%29%20,now%28%29%20%2F%201000)); se presente, lo decodifica e verifica che non sia scaduto confrontando l'epoch corrente con `exp` del token ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=if%20%28token%29%20,now%28%29%20%2F%201000)). Se il token è ancora valido, lo store lo imposta come token corrente e chiama di nuovo `fetchUserData()` per sincronizzare lo stato utente ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=if%20%28decodedToken.exp%20,else)). In tal modo, l'utente rimane loggato automaticamente senza dover reinserire le credenziali, finché il token JWT è valido. Se invece il token risulta scaduto o invalido, lo store effettua un logout silenzioso (`this.logout()`) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=%7D%20else%20,logout%28%29%3B)), rimuovendo quel token non più utile. Questo meccanismo consente il **riconoscimento automatico** della sessione utente se un token valido è ancora presente (simile al "remember me"). Il valore di `rememberMe` passato durante il login potrebbe far sì che il backend emetta un token con durata più lunga o imposti anche un cookie di refresh (dipende dall'implementazione Spring), ma dal lato frontend la gestione è la stessa: memorizzare il token e riutilizzarlo.

**3. Protezione delle rotte e autorizzazione:** Il sistema utilizza i middleware di Nuxt per garantire che solo gli utenti appropriati accedano a certe pagine. Il middleware `auth.ts` viene applicato a tutte le rotte che richiedono login. Quando l'utente, dopo aver effettuato il login, viene reindirizzato alla home (`/`), questo middleware controlla `authStore.isAuthenticated`. Se per qualche motivo non lo fosse, lo redirigerebbe di nuovo al login ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=%2F%2F%20If%20still%20not%20authenticated,return%20navigateTo%28%27%2Fauth%2Flogin%27%29%3B)). Ma assumendo che il login abbia settato tutto correttamente, l'accesso è concesso. Se invece l'utente da non autenticato prova a navigare manualmente a una pagina interna (digitando l'URL o seguendo un link senza aver fatto login), il middleware `auth` se ne accorge: `isAuthenticated` sarà false, allora chiama `initAuth` per vedere se c'è un token valido (magari la persona aveva un token attivo in storage) ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=if%20%28%21authStore.isAuthenticated%29%20)). Se dopo initAuth ancora non c'è autenticazione valida, viene eseguito `navigateTo('/login')` ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=%2F%2F%20If%20still%20not%20authenticated,return%20navigateTo%28%27%2Fauth%2Flogin%27%29%3B)), reindirizzando al login. Così le pagine riservate sono al sicuro. Allo stesso modo, se un utente loggato cerca di tornare alla pagina di login o registrazione, il middleware lo manda indietro alla home ([report_middleware_auth.ts.md](file://file-WHVrPjfiTqpH3QcaQF8tLF#:~:text=%2F%2F%20If%20authenticated%20and%20trying,return%20navigateTo%28%27%2F%27%29%3B)), poiché ha poco senso presentare di nuovo il form di login a chi è già dentro. Per le pagine amministrative, oltre al middleware `auth`, è attivo `admin.ts` (spesso basta indicare `middleware: ['admin']` sulla rotta perché esso internamente controlla anche l'auth): questo verifica `authStore.isAdmin` e se è false reindirizza alla home ([report_middleware_admin.ts.md](file://file-VfuZRgrT2EhsjRQtH62SoD#:~:text=if%20%28%21authStore.isAdmin%29%20)). Quindi un utente loggato ma non admin non può visualizzare quelle pagine (anche se provasse l'URL). In aggiunta, lo store utenti effettua un controllo simile prima di ogni azione (cintura e bretelle) ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=async%20fetchUsers,%21authStore.isAdmin%29%20return)). Grazie a questi controlli multipli, l'app **autorizza** l'accesso alle funzionalità avanzate solo ai ruoli giusti e **autentica** ogni richiesta.

**4. Processo di Logout e scadenza sessione:** L'utente può terminare la sessione manualmente (ad esempio cliccando un pulsante "Logout" nell'interfaccia). Tipicamente quel pulsante chiamerà `useAuth().logout()`, che a sua volta invoca `authStore.logout()` e poi redirige a `/login` ([report_composables_useAuth.ts.md](file://file-KnELCpJvzZ18Z4s8QB3LYH#:~:text=const%20logout%20%3D%20%28%29%20%3D,push%28%27%2Fauth%2Flogin%27%29%3B)). Lo store in `logout()` rimuove il token e i dati utente e pulisce il localStorage ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=logout%28%29%20,removeItem%28%27auth_token%27%29%3B)). Ciò rende immediatamente `isAuthenticated = false`. Subito il middleware `auth` vedendo che la pagina corrente richiede auth (se si era in una rotta protetta) forzerà di nuovo il redirect al login. In pratica però, `useAuth.logout` già sposta l'utente al login, quindi avviene rapidamente. Se invece il token **scade** mentre l'utente sta usando l'app (scenario di timeout): alla prima richiesta protetta che si fa con token scaduto, il backend Spring Boot risponderà con **401 Unauthorized**. L'interceptor globale di Axios intercetta questo 401/403 e reagisce rimuovendo il token dal localStorage e facendo `window.location.href = '/login'` ([report_plugins_axios.ts.md](file://file-S9z2E2PiPt2LW2a2cQLQYm#:~:text=%7D%2C%20%28error%29%20%3D,return%20Promise.reject%28error%29%3B)). Questo provoca un reload della pagina di login. Contestualmente, avendo rimosso il token, se lo store `auth` rimane in memoria, l'utente non è più autenticato. Di fatto, si effettua un logout automatico. Quando l'utente viene rimandato al login in questo modo, può dover effettuare di nuovo l'accesso. L'app dunque gestisce anche la scadenza o revoca del token in maniera elegante, evitando che l'utente continui a usare credenziali non più valide. 

In sintesi, il flusso di autenticazione coordina **frontend e backend**: il backend emette e verifica i JWT, il frontend li conserva e li invia. Lo store Pinia e i middleware garantiscono che l'interfaccia utente reagisca correttamente allo stato (mostrando le pagine giuste, reindirizzando se necessario), mentre il plugin Axios automatizza l'inclusione e la validazione del token nelle chiamate API. Il risultato è un'esperienza dove l'utente effettua login una volta, può navigare le sezioni autorizzate, e se prova ad accedere a qualcosa di non permesso (o se la sessione scade) viene immediatamente gestito (bloccato o mandato al login).

# Esempi di utilizzo

Di seguito alcuni scenari pratici che illustrano come componenti, store e middleware collaborano nel sistema di autenticazione:

- **Esempio 1: Login e accesso a una pagina protetta** – Un nuovo utente apre l'applicazione e viene presentato con il form di login. Inserisce le credenziali e preme "Accedi". Il componente `LoginForm.vue` tramite `useAuth.login` effettua la chiamata di autenticazione. I dati inviati al backend Spring Boot vengono verificati e il server risponde con un token JWT e i dettagli utente. Lo store di autenticazione salva il token e le info utente, indicando che l'utente è autenticato con successo. A questo punto, il composable `useAuth` fa navigare il browser alla pagina home (`/`). Questa pagina è protetta dal middleware `auth.ts`, che ora trova `authStore.isAuthenticated = true` (l'utente è loggato) e quindi permette l'accesso. La pagina può ad esempio mostrare un messaggio di benvenuto con il nome dell'utente, ottenuto dallo store (tramite `useAuth().user`). Ogni contenuto o componente che necessita di sapere chi è l'utente loggato può ottenerlo dallo store senza fare ulteriori chiamate. Se l'utente fa refresh della pagina, il middleware `auth` chiama `initAuth`: lo store rileva il token nel localStorage, lo valida e ricarica i dati utente dal server, ristabilendo lo stato di login senza chiedere nuovamente username e password. Dunque l'utente rimane loggato. Da questo momento, se l'utente interagisce con funzionalità che richiedono chiamate API (es. aggiornare il proprio profilo, caricare dati personali), il token viene incluso automaticamente dal plugin Axios nelle richieste, e il backend risponderà con i dati richiesti. L'utente può navigare liberamente tra le pagine protette; se tenta di accedere alla pagina di login manualmente, il middleware lo riporterà alla home, prevenendo comportamenti incoerenti.

- **Esempio 2: Accesso all'area amministrativa e gestione utenti** – Un utente con ruolo amministratore, dopo aver effettuato il login come sopra, decide di accedere alla sezione di amministrazione utenti (ad esempio `/admin/users`). Questa rotta è protetta dal middleware `admin.ts`. All'atto di navigarvi, `admin.ts` controlla che l'utente sia autenticato (vero) e che `authStore.isAdmin` sia true. Il valore di `isAdmin` è stato impostato dallo store auth in base alle authorities dell'utente caricate dal backend (si supponga che l'utente abbia `ROLE_ADMIN` tra i suoi ruoli) ([report_stores_auth.ts.md](file://file-UZZEMSszsGxu6jLy2QTpZr#:~:text=getters%3A%20,null)). Essendo un admin, il middleware permette l'accesso. Nella pagina utenti, poniamo ci sia un componente `UserList.vue` che mostra la lista di tutti gli utenti registrati. Allo montaggio, questo componente può usare il composable `useUsers`: ad esempio, chiama `const { users, fetchUsers, loading } = useUsers()` in `<script setup>` e poi esegue `fetchUsers()` magari dentro a un `onMounted`. La funzione `fetchUsers` del composable richiama l'azione `usersStore.fetchUsers` nello store ([report_composables_useUsers.ts.md](file://file-BFWfBj82yuWMaHMHtCyRgL#:~:text=const%20fetchUsers%20%3D%20async%20,fetchUsers%28page%2C%20size%29%3B)). Lo store utenti verifica che l'utente corrente sia admin tramite lo store auth (condizione vera in questo caso) ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=async%20fetchUsers,%21authStore.isAdmin%29%20return)) e procede a fare la chiamata API `GET /api/admin/users` con il token nell'header ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=const%20config%20%3D%20useRuntimeConfig,authStore.getToken%7D%60%20%7D)). Il backend Spring Boot autentica il token, riconosce che è un admin e restituisce l'elenco degli utenti (ad esempio in formato JSON). Lo store mette `this.users = response.data` aggiornando la lista utenti interna ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=this,size%20%3D%20size)). Siccome `useUsers().users` è una proprietà reattiva collegata a `usersStore.getUsers`, appena lo store aggiorna i dati, il componente `UserList.vue` vede la lista `users` popolata e rende in pagina la tabella degli utenti. Durante il caricamento, `usersStore.loading` è true, così il componente potrebbe mostrare uno spinner (leggendolo tramite `useUsers().loading`). Se si verifica un errore (es. token scaduto, o server offline), `usersStore.error` verrebbe valorizzato e il componente potrebbe visualizzarlo (tramite `useUsers().error`). Ora l'amministratore decide di creare un nuovo utente tramite un modulo. Quando conferma, il componente di creazione utente chiama `useUsers().createUser(newUserData)`. Il composable invoca `usersStore.createUser`, che controlla di nuovo i permessi e poi fa `POST /api/admin/users` col token ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=try%20,authStore.getToken%7D%60%20%7D)). Il server crea l'utente e risponde. Lo store, dopo la risposta positiva, chiama `this.fetchUsers(this.page, this.size)` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=)) per ricaricare la lista aggiornata. Ciò fa partire un'altra richiesta GET e aggiorna `usersStore.users`. Di conseguenza, il componente lista utenti si aggiorna automaticamente mostrando anche il nuovo utente appena creato, senza bisogno di ricaricare manualmente la pagina. La stessa logica avviene per modifiche o cancellazioni: ad esempio, se l'admin elimina un utente dalla lista (tramite `deleteUser`), lo store invia `DELETE /api/admin/users/username` ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=try%20,authStore.getToken%7D%60%20%7D)) e, se OK, ricarica la lista utenti ([report_stores_users.ts.md](file://file-Nr6kHnb4Yu86kNfK8UiZh4#:~:text=)). Il componente vedrà la lista aggiornata (utente rimosso). Durante tutte queste azioni, l'interceptor Axios garantisce che se per qualche ragione il token fosse divenuto invalido, la risposta 401 dal server farebbe scattare un redirect al login. L'admin dunque sarebbe costretto a rieffettuare l'accesso, assicurando sicurezza. In ogni caso, se l'admin dovesse perdere i privilegi a sessione in corso (caso raro, di solito i ruoli non cambiano al volo), il backend restituirebbe 403 Forbidden alle chiamate admin e l'interceptor lo riporterebbe al login, oppure lo store utente imposterebbe un errore di permessi. Infine, quando l'amministratore termina il suo lavoro e clicca "Logout", `useAuth.logout` pulisce lo stato e lo porta alla schermata di login. Se l'admin non premesse logout ma semplicemente chiudesse la scheda, il token rimarrebbe in localStorage; alla prossima visita, se ancora valido, `initAuth` lo riloggherà automaticamente.

In questi esempi si nota come i **componenti Vue (UI)**, i **composables (logica di front-end)**, gli **store Pinia (stato e chiamate API)** e i **middleware (protezione navigazione)** interagiscono armoniosamente. Il componente presenta l'interfaccia e delega le operazioni ai composables; questi attivano gli store che comunicano col backend e aggiornano lo stato; i cambiamenti di stato si riflettono immediatamente sulla UI grazie alla reattività di Vue; i middleware controllano a monte l'accesso alle pagine e reagiscono ai cambi di stato (ad esempio redirect in caso di logout). Tutto ciò avviene sfruttando il token JWT come elemento di autenticazione: una volta ottenuto, circola attraverso header HTTP (grazie al plugin Axios) e condiziona il comportamento dell'app (ad esempio mostrare funzionalità admin solo se il token contiene quel ruolo, come reso evidente da `authStore.isAdmin`). In conclusione, il sistema offre un flusso coerente: **login -> navigazione autorizzata -> eventuali operazioni -> logout**, con feedback all'utente (messaggi di errore, loading indicator) appropriati, supporto multilingua nei testi, e mantenendo sempre allineato il front-end con lo stato reale dell'utente fornito dal backend.